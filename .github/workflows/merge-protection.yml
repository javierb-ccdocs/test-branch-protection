name: Merge Protection

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  check-merge-requirements:
    name: Check Merge Requirements
    runs-on: ubuntu-latest
    steps:
      - name: Get PR details
        id: pr-info
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            core.setOutput('draft', pr.draft);
            core.setOutput('mergeable', pr.mergeable);
            core.setOutput('mergeable_state', pr.mergeable_state);
            core.setOutput('review_count', pr.requested_reviewers?.length || 0);
            
            return {
              draft: pr.draft,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
              review_count: pr.requested_reviewers?.length || 0,
            };

      - name: Check PR is not draft
        if: steps.pr-info.outputs.draft == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            // Skip draft PRs silently - no comment needed
            console.log('‚ÑπÔ∏è Draft PR - skipping checks');

      - name: Check required status checks and block merge if failed
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            // Skip if PR is draft
            if (pr.draft) {
              console.log('‚ÑπÔ∏è Draft PR - skipping status check enforcement');
              return;
            }
            
            // Get all status checks for this commit
            const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha,
            });
            
            // Define all required checks (including existing ones)
            const requiredChecks = [
              'CodeRabbit',
              'deploy',
              'Lint and Build',
              'Docker Build Test',
              'Required Checks / lint',
              'Required Checks / test',
              'Required Checks / build',
              'PR Validation / validate-pr'
            ];
            
            // Check which checks have passed/failed
            const checkResults = {};
            requiredChecks.forEach(check => {
              const status = statuses.find(s => s.context === check);
              if (status) {
                checkResults[check] = status.state; // 'success', 'failure', 'pending', 'error'
              } else {
                checkResults[check] = 'pending'; // Not run yet
              }
            });
            
            // Find failed or pending checks
            const failedChecks = Object.entries(checkResults)
              .filter(([check, state]) => state === 'failure' || state === 'error')
              .map(([check]) => check);
            
            const pendingChecks = Object.entries(checkResults)
              .filter(([check, state]) => state === 'pending')
              .map(([check]) => check);
            
            // Wait for all checks to complete before commenting
            // Only comment if ALL checks are done (no pending checks)
            if (pendingChecks.length > 0) {
              // Still waiting for checks - don't comment yet
              console.log(`Waiting for checks: ${pendingChecks.join(', ')}`);
              return;
            }
            
            // All checks completed - now decide what to do
            if (failedChecks.length > 0) {
              // Checks failed - close PR with summary
              if (pr.state === 'open') {
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  state: 'closed'
                });
                
                // Create ONE summary comment
                const failedList = failedChecks.map(c => `- ${c}`).join('\n');
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `üö´ **PR Closed - Checks Failed**\n\nFailed: ${failedChecks.length} check(s)\n\n${failedList}\n\nFix issues and push new commits to reopen.`
                });
              }
              
              core.setFailed(`Required checks failed: ${failedChecks.join(', ')}`);
            } else {
              // All checks passed
              if (pr.state === 'closed' && pr.merged === false) {
                // Reopen if it was auto-closed
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  state: 'open'
                });
              }
              // Don't comment on success - CODEOWNERS will get notification when PR is ready for review
              console.log('‚úÖ All checks passed - PR ready for review');
            }

      - name: Check for conflicts
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            if (pr.mergeable === false) {
              // Only comment if PR is still open (not already closed by validation)
              if (pr.state === 'open') {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: '‚ö†Ô∏è **Merge Conflicts:** Resolve conflicts before merging.'
                });
              }
            }
