name: Merge Protection

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  check-merge-requirements:
    name: Check Merge Requirements
    runs-on: ubuntu-latest
    steps:
      - name: Get PR details
        id: pr-info
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            core.setOutput('draft', pr.draft);
            core.setOutput('mergeable', pr.mergeable);
            core.setOutput('mergeable_state', pr.mergeable_state);
            core.setOutput('review_count', pr.requested_reviewers?.length || 0);
            
            return {
              draft: pr.draft,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
              review_count: pr.requested_reviewers?.length || 0,
            };

      - name: Check PR is not draft
        if: steps.pr-info.outputs.draft == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚ÑπÔ∏è **Draft PR:** This PR is still in draft. Mark as ready for review when ready to merge.'
            });

      - name: Check required status checks and block merge if failed
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            // Skip if PR is draft
            if (pr.draft) {
              console.log('‚ÑπÔ∏è Draft PR - skipping status check enforcement');
              return;
            }
            
            // Get all status checks for this commit
            const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha,
            });
            
            // Define all required checks (including existing ones)
            const requiredChecks = [
              'CodeRabbit',
              'deploy',
              'Lint and Build',
              'Docker Build Test',
              'Required Checks / lint',
              'Required Checks / test',
              'Required Checks / build',
              'PR Validation / validate-pr'
            ];
            
            // Check which checks have passed/failed
            const checkResults = {};
            requiredChecks.forEach(check => {
              const status = statuses.find(s => s.context === check);
              if (status) {
                checkResults[check] = status.state; // 'success', 'failure', 'pending', 'error'
              } else {
                checkResults[check] = 'pending'; // Not run yet
              }
            });
            
            // Find failed or pending checks
            const failedChecks = Object.entries(checkResults)
              .filter(([check, state]) => state === 'failure' || state === 'error')
              .map(([check]) => check);
            
            const pendingChecks = Object.entries(checkResults)
              .filter(([check, state]) => state === 'pending')
              .map(([check]) => check);
            
            // If PR is closed, check if we should reopen it
            if (pr.state === 'closed' && failedChecks.length === 0 && pendingChecks.length === 0) {
              // All checks passed, reopen PR
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                state: 'open'
              });
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '‚úÖ **All checks passed!** PR has been reopened and is ready to merge.'
              });
              return;
            }
            
            // If checks failed, close the PR to block merging
            if (failedChecks.length > 0) {
              if (pr.state === 'open') {
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  state: 'closed'
                });
              }
              
              const failedList = failedChecks.map(c => `- ‚ùå ${c}`).join('\n');
              const pendingList = pendingChecks.length > 0 
                ? '\n\n**Pending checks:**\n' + pendingChecks.map(c => `- ‚è≥ ${c}`).join('\n')
                : '';
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `üö´ **PR CLOSED - Checks Failed**\n\nThis PR has been automatically closed because the following required checks failed:\n\n${failedList}${pendingList}\n\n**Fix the issues and push new commits to reopen this PR.**`
              });
              
              core.setFailed(`Required checks failed: ${failedChecks.join(', ')}`);
            } else if (pendingChecks.length > 0) {
              // Some checks still pending, just comment
              const pendingList = pendingChecks.map(c => `- ‚è≥ ${c}`).join('\n');
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `‚è≥ **Waiting for checks to complete:**\n\n${pendingList}\n\nPR will be automatically closed if any checks fail.`
              });
            }

      - name: Enforce PR description
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const minDescriptionLength = 20;
            
            if (!pr.body || pr.body.trim().length < minDescriptionLength) {
              core.setFailed(`PR description must be at least ${minDescriptionLength} characters`);
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `‚ùå **PR Description Required:** Please add a description explaining:\n- What changes were made\n- Why the changes were needed\n- Any breaking changes\n\nMinimum ${minDescriptionLength} characters required.`
              });
            }

      - name: Check for conflicts
        uses: actions/github-script@v6
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            if (pr.mergeable === false) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '‚ö†Ô∏è **Merge Conflicts:** This PR has merge conflicts that must be resolved before merging.'
              });
            }

      - name: Summary
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            console.log('‚úÖ Merge protection checks completed');
            console.log('Review the comments above for any issues that need to be addressed.');
